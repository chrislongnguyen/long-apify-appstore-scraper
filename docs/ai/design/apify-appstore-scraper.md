---
phase: design
title: System Design - App Volatility Analyzer (Python Edition)
description: Technical architecture for the deterministic extraction and statistical scoring of App Store reviews (Bilingual Support).
---

# 1. EFFECTIVE FEATURE DESIGN

## 1.1 Feature Definition
* **Noun (The Tool):** `AppVolatilityAnalyzer` (CLI Tool)
    * **Core Function:** A Python-based ETL pipeline that orchestrates the Apify `apple-store-reviews` Actor, ingests raw JSON, performs statistical analysis (Trend/Slope/Keyword Density) using Pandas, and outputs a "Risk Scorecard" for target apps.

## 1.2 Effectiveness Attributes
* **Sustainability Adjectives (Robustness):**
    * *Adjective:* **Deterministic** (Math-Based)
        * *Implementation:* All scoring logic uses standard deviation, linear regression slopes, and keyword frequency counts. No LLM probabilistic generation is used for metrics.
    * *Adjective:* **Fault-Tolerant** (Apify Wrappers)
        * *Implementation:* Wrap API calls in `tenacity` retry blocks to handle network jitters. Fail gracefully if an App ID is invalid (log error, continue to next app).

* **Efficiency Adjectives (Optimization):**
    * *Adjective:* **Vectorized** (High Speed)
        * *Implementation:* Use `pandas` vector operations for text searching and date filtering instead of iterating through Python lists.
    * *Adjective:* **Thrifty** (Token Conservation)
        * *Implementation:* Filtering happens *in-memory* immediately after fetch. We do not persist generic 5-star reviews to disk, saving storage and visual noise.

* **Scalability Adjectives (Volume):**
    * *Adjective:* **Config-Driven** (Batch Processing)
        * *Implementation:* The system accepts a `targets.json` array, allowing the user to scan 1, 10, or 50 apps in a single command.
    * *Adjective:* **Polylingual** (Global Reach)
        * *Implementation:* `pain_keywords.json` supports arrays of strings, enabling English/Vietnamese detection simultaneously without code changes.

## 1.3 Architecture & Data

### Visual Map (Mermaid)

```mermaid
graph TD
    User((User)) -->|1. Run Command| CLI[main.py]
    CLI -->|2. Load Configs| Config[targets.json & pain_keywords.json]
    CLI -->|3. Trigger| Fetcher[Fetcher Class]
    
    subgraph "External Cloud"
        Fetcher -->|API Call| Apify[Apify Actor: thewolves/appstore-reviews]
        Apify -->|Raw Data| JSON[Raw Reviews JSON]
    end
    
    Fetcher -->|4. Pass Data| Analyzer[Analyzer Class (Pandas)]
    
    subgraph "Local Processing (Deterministic)"
        Analyzer -->|Filter| DF1[Last 90 Days Only]
        DF1 -->|Calc| Slope[Slope Calculation (NumPy)]
        DF1 -->|Search| Keywords[Regex Match vs pain_keywords.json]
        Slope & Keywords -->|Compute| Score[Risk Score Formula]
    end
    
    Analyzer -->|5. Structured Data| Artifact[schema_app_gap.json]
    Artifact -->|6. Render| Reporter[Reporter Class]
    Reporter -->|7. Output| MD[report_APPNAME.md]

Data Models (Schema)
1. Input Configuration (config/targets.json)
{
  "apps": [
    { "name": "CompetitorX", "url": "[https://apps.apple.com/](https://apps.apple.com/)..." },
    { "name": "IncumbentY", "url": "[https://apps.apple.com/](https://apps.apple.com/)..." }
  ],
  "params": {
    "days_back": 90,
    "max_reviews": 500
  }
}s

2. System Settings (`config/settings.json`)
This file controls the "Thrifty" filters and "Risk Score" weights without code changes.

```json
{
  "filters": {
    "min_star_rating": 4, 
    "min_review_length_words": 3,
    "drop_generic_5_star": true,
    "force_fetch_count": 10
  },
  "weights": {
    "slope_impact": 20.0,
    "volume_impact": 0.5,
    "critical_keyword": 10.0,
    "scam_keyword": 8.0,
    "performance_keyword": 5.0,
    "ux_keyword": 2.0
  },
  "processing": {
    "enable_smoke_test": false,
    "days_back_default": 90
  }
}

3. The Output Artifact (schema_app_gap.json)
This is the "Truth Source" generated by the Python script.
{
  "app_name": "CompetitorX",
  "analysis_date": "2023-10-27",
  "metrics": {
    "total_reviews_90d": 150,
    "negative_ratio": 0.45,
    "volatility_slope": 0.8,
    "risk_score": 78.5
  },
  "signals": {
    "broken_update_detected": true,
    "suspected_version": "5.2.1",
    "top_pain_categories": [
      { "category": "scam_financial", "count": 18, "weight": 8 },
      { "category": "critical", "count": 12, "weight": 10 }
    ]
  },
  "evidence": [
    "Raw text of review 1...",
    "Raw text of review 2..."
  ]
}

3. The Scoring Formula (LaTeX)
The risk_score is calculated as a composite index:$$RiskScore = \min(100, (W_{slope} \times S) + (W_{vol} \times V) + \sum (C_i \times W_i))$$Where:
Trend Impact ($S$): $W_{slope} = 20$. If slope > 0.5, score +20.
Volume Impact ($V$): $W_{vol} = 0.5$. If 50 negative reviews, score +25.
Pain Impact ($\sum$): Sum of (Count of Category $i$ $\times$ Weight of Category $i$).
Example: 2 Crashes ($2 \times 10$) + 3 Lags ($3 \times 5$) = 35 points.

1.4 RESOURCE IMPACT ANALYSIS
Financial Impact (OpEx)
External Costs: Apify thewolves/appstore-reviews-scraper.

Cost per run: ~$0.10 - $0.20 per 1,000 reviews.

Projected Run Rate: For 10 apps/week -> <$2.00/month (Well within the $5.00 limit).

Compute: Local (Free).

Build Cost (One-Time)
Time to Build: Low (1-2 Days).

Day 1: Apify Integration & Pandas Logic (with Regex).

Day 2: Report Formatting & Testing.

Complexity Risk: Low.

Main risk is Apify changing their output schema (mitigated by strictly typing the inputs).

ROI Sanity Check
Value Proposition: Manually analyzing 500 reviews takes ~4 hours. This script does it in 30 seconds with mathematical consistency across languages.

Alignment: Perfectly fits the "Efficiency" constraint by automating the "Discovery" phase of the Venture Builder.